{"version":3,"sources":["mainScript.js"],"names":["window","addEventListener","parallaxConteiner","document","querySelector","layers","children","e","pageX","pageY","initialX","innerWidth","initialY","innerHeight","slice","call","forEach","layer","i","divider","positionX","positionY","bottomPosition","layerStyle","style","transformString","transform","bottom","bg","userText","sectionText","wrapper","form","svg","svgPatchGroup","windowMargin","svgPos","parallax","move","block","windowScroll","strafeAmount","webkitTransform","init","wScroll","this","blur","set","imgWidth","offsetWidth","posLeft","offsetLeft","posTop","offsetTop","blurCss","backgroundSize","backgroundPosition","svgScroll","querySelectorAll","getBoundingClientRect","top","grow","startAnimate","pixelsElapsed","percentsElapsed","Math","ceil","drawAmount","item","strokeDashoffset","pageYOffset"],"mappings":"AAAA,aAEAA,OAAAC,iBAAA,OAAA,WAEA,IAAAC,EAAAC,SAAAC,cAAA,aACAC,EAAAH,EAAAI,SAEAJ,EAAAD,iBAAA,YAEA,SAAAM,GAEA,IAAAC,EAAAD,EAAAC,MACAC,EAAAF,EAAAE,MAEAC,EAAAV,OAAAW,WAAA,EAAAH,EACAI,EAAAZ,OAAAa,YAAA,EAAAJ,EAIA,GAAAK,MAAAC,KAAAV,GAAAW,QAAA,SAAAC,EAAAC,GAEA,IAAAC,EAAAD,EAAA,IAEAE,EAAAV,EAAAS,EACAE,EAAAT,EAAAO,EAEAG,EAAAtB,OAAAa,YAAA,EAAAM,EAEAI,EAAAN,EAAAO,MAEAC,EAAA,eAAAL,EAAA,OAAAC,EAAA,UAEAE,EAAAG,UAAAD,EAEAF,EAAAI,OAAA,IAAAL,EAAA,WAQAtB,OAAAC,iBAAA,OAAA,WAEA,IACA2B,EACAC,EACAC,EA+BAC,EACAC,EAqBAC,EACAC,EAEAC,EAGAC,EA9DAC,GACAT,EAAAzB,SAAAC,cAAA,yBACAyB,EAAA1B,SAAAC,cAAA,2BACA0B,EAAA3B,SAAAC,cAAA,mCAGA,CAEAkC,KAAA,SAAAC,EAAAC,EAAAC,GAEA,IAEAhB,EAAA,iBAFAe,GAAAC,EAAA,QAIAjB,EAAAe,EAAAf,MAMAA,EAAAE,UAAAD,EACAD,EAAAkB,gBAAAjB,GAIAkB,KAAA,SAAAC,GACAC,KAAAP,KAAAV,EAAAgB,EAAA,IACAC,KAAAP,KAAAT,EAAAe,EAAA,IACAC,KAAAP,KAAAR,EAAAc,EAAA,MAKAE,GACAf,EAAA5B,SAAAC,cAAA,uBACA4B,EAAA7B,SAAAC,cAAA,eAGA,CACA2C,IAAA,WAEA,IAAAC,EAAA7C,SAAAC,cAAA,qBAAA6C,YAEAC,GAAAnB,EAAAoB,WACAC,GAAArB,EAAAsB,UAEAC,EAAAtB,EAAAR,MAEA8B,EAAAC,eAAAP,EAAA,UAEAM,EAAAE,mBAAAN,EAAA,MAAAE,EAAA,QAKAK,GACAxB,EAAA9B,SAAAC,cAAA,eACA8B,EAAA/B,SAAAuD,iBAAA,sBAEAvB,EAAAnC,OAAAa,YAAA,EAGAuB,EADAH,EAAA0B,wBACAC,IAGA,CACAC,KAAA,SAAAjB,GACA,IAAAkB,EAAAlB,EAAAR,EAAAD,EACA4B,EAAA3B,EAAAQ,EACAoB,EAAA,IAAAC,KAAAC,KAAAH,EAAA5B,EAAA,KAGA,GAAA,GAAA2B,EAAA,CACA,IAAAK,EAAA,KAHA,GAAAH,EAKA,EAAAG,GACAjC,EAAAlB,QAAA,SAAAoD,GACAA,EAAA5C,MAAA6C,iBAAAF,QAQArB,EAAAC,MAEA/C,OAAAC,iBAAA,SACA,WAEA,IAAA2C,EAAA5C,OAAAsE,YAEAjC,EAAAM,KAAAC,GACAa,EAAAI,KAAAjB,KAGA5C,OAAAC,iBAAA,SACA,WACA6C,EAAAC","file":"scripts.min.js","sourcesContent":["'use strict';\n/*параллакс по движению курсора*/\nwindow.addEventListener('load', function () {\n\n    let parallaxConteiner = document.querySelector('#parallax'),\n        layers = parallaxConteiner.children;\n\n    parallaxConteiner.addEventListener('mousemove', moveLayers);\n\n    function moveLayers(e) {\n            // вычисляем позицию курсора\n        let pageX = e.pageX,\n            pageY = e.pageY,\n            // вычисляем условный центр видемой зоны контейнера с параллаксом, отклонение положения курсора от условного центра.\n            initialX = (window.innerWidth / 2) - pageX,\n            initialY = (window.innerHeight / 2) - pageY;\n\n                    //метод массива slice передаем в качестве this, перебираем элементы коллекции.\n            // slice создает копию массива из перебранных элементов.\n            [].slice.call(layers).forEach(function (layer, i) {\n                    // divider - перемення (фоэффициент скорости движения слоя), в которую будет выводиться индекс эл-а в наборе, где значение будет делиться на 100.\n                let divider = i / 100,\n                    // вычисляем позицию i-го слоя относительно условного центра с учетом коэф. скорости движения слоя\n                    positionX = initialX * divider,\n                    positionY = initialY * divider,\n                    // bottomPosition - переменная, с помощью которой решаем проблему выпадания слоев в нижней части контейнера. Рассчет проводится с учетом коэф. divider.\n                    bottomPosition = (window.innerHeight / 2 ) * divider,\n                    // сохраняем стили слоя в переменной\n                    layerStyle = layer.style,\n                    // задаем переменную , указывающую на сколько будем сдвигать слой по осям\n                    transformString = 'translate3d(' +  positionX + 'px ,' +  positionY + 'px , 0)';\n\n                    layerStyle.transform = transformString;\n                    // убираем проблемы с выпадением слоев\n                    layerStyle.bottom = '-' +  bottomPosition + 'px';\n            });\n\n    } // moveLayers\n\n}); // load\n\n/*параллакс по скроллу*/\nwindow.addEventListener('load', function () {\n\n    let parallax = (function () {\n        let bg = document.querySelector('.parallaxScrollJs__bg');\n        let userText = document.querySelector('.parallaxScrollJs__text');\n        let sectionText = document.querySelector('.parallaxScrollJs__section--img');\n\n        /*возвращаем объект с публичными методами */\n        return{\n            /*заводим функцию move, которая будет двигать наши слои. В move передаем блок, который будем сдвигать, значение скролла, и передавать коэф, на который будем делить кол. пролистанных px, в зовисимости от этого будет меняться скорость смещения.*/\n            move: function (block, windowScroll, strafeAmount) {\n                // рассчитываем коэф. (минус берем, что бы эл-ты двигались в противоположную сторону относительно скролла\n                let strafe = windowScroll / -strafeAmount + '%';\n\n                let transformString = 'translate3d(0,' + strafe + ', 0)';\n\n                let style = block.style;\n\n                // смещаем блок\n                // style.top = strafe;\n\n                // а это позволяет сделать более плавную анимациюб переносим затраты на отрисовку на видиокарту\n                style.transform = transformString;\n                style.webkitTransform = transformString;\n            },\n\n            /*заводим публичный метод для сбора всех вызовов слоев*/\n            init: function (wScroll) {\n                this.move(bg, wScroll, 40);\n                this.move(userText, wScroll, 10);\n                this.move(sectionText, wScroll, 3);\n            }\n        }\n    }());\n\n    let blur = (function () {\n       let wrapper = document.querySelector('.blur__form-wrapper'),\n           form = document.querySelector('.blur__form');\n\n\n       return{\n           set: function () {\n               /*ширина картинки в подложке*/\n               let imgWidth = document.querySelector('.blur__background').offsetWidth;\n               /*расстояние относительно родителя слева и сверху*/\n               let posLeft = -wrapper.offsetLeft;\n               let posTop = -wrapper.offsetTop;\n\n               let blurCss = form.style;\n\n               blurCss.backgroundSize = imgWidth + 'px' + ' ' + 'auto';\n               /*обязательно вставлять пробел между данными по позиционированию, иначе стили не будут применены!*/\n               blurCss.backgroundPosition = posLeft + 'px' + ' ' + posTop + 'px';\n           }\n       }\n    }());\n\n    let svgScroll = (function () {\n        let svg = document.querySelector('#heisenberg'),\n            svgPatchGroup = document.querySelectorAll('#heisenberg .group'),\n            /*начало анимации зависит от расстояния до верхней границы окна c учетом отступа от него*/\n            windowMargin = window.innerHeight / 3,\n            /*положение svg*/\n            svgRect = svg.getBoundingClientRect(),\n            svgPos = svgRect.top;\n\n\n        return{\n            grow: function (wScroll) {\n                let startAnimate = wScroll - svgPos + windowMargin,\n                    pixelsElapsed = svgPos - wScroll,\n                    percentsElapsed = 100 - Math.ceil(pixelsElapsed / windowMargin * 100),\n                    percentsDraw = 1200 / 100 * percentsElapsed;\n\n                if(startAnimate >= 0){\n                    let drawAmount = 1200 - percentsDraw;\n\n                    if(drawAmount > 0){\n                        svgPatchGroup.forEach(function (item) {\n                            item.style.strokeDashoffset = drawAmount;\n                        })\n                    }\n                }\n            },\n        }\n    }());\n\n    blur.set();\n\n    window.addEventListener('scroll', scrollPage);\n    function scrollPage() {\n\n        let wScroll = window.pageYOffset; /*выясняем на сколько px проскроллена страница*/\n\n        parallax.init(wScroll);\n        svgScroll.grow(wScroll);\n    }\n\n    window.addEventListener('resize', resizePage);\n    function resizePage() {\n        blur.set();\n    }\n\n}); // load\n\n\n\n"]}